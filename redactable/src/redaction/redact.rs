//! Application layer: Redaction machinery.
//!
//! This module provides the infrastructure for applying redaction:
//!
//! - [`RedactableMapper`]: Internal trait for mapping values during traversal
//! - [`PolicyApplicable`]: Types that can have policies applied recursively
//! - [`redact`]: The entry point function for redacting a value
//! - [`ScalarRedaction`]: Helper trait for scalar default values
//!
//! ## How PolicyApplicable Works
//!
//! For a field like:
//! ```ignore
//! #[sensitive(Token)]
//! api_keys: Option<Vec<String>>
//! ```
//!
//! The generated code calls:
//! ```ignore
//! PolicyApplicable::apply_policy::<Token, _>(api_keys, mapper)
//! ```
//!
//! At runtime, this recursively descends:
//! 1. `Option<Vec<String>>` → calls `.map(|v| v.apply_policy::<Token, _>(mapper))`
//! 2. `Vec<String>` → calls `.into_iter().map(|v| v.apply_policy::<Token, _>(mapper)).collect()`
//! 3. `String` → calls `mapper.map_sensitive::<_, Token>(self)`
//!
//! The recursion handles any nesting depth automatically!

use std::{
    borrow::Cow,
    collections::{BTreeMap, BTreeSet, HashMap, HashSet},
    hash::{BuildHasher, Hash},
};

use super::traits::{RedactableContainer, RedactableWithPolicy};
use crate::policy::RedactionPolicy;

// =============================================================================
// RedactableMapper - Internal mapping trait
// =============================================================================

/// Maps sensitive and non-sensitive values during traversal.
///
/// This is the internal machinery that applies redaction policies.
/// Implementations must return the same value type for `map_sensitive`.
#[doc(hidden)]
pub trait RedactableMapper {
    /// Maps a sensitive, string-like value.
    fn map_sensitive<V, P>(&self, value: V) -> V
    where
        V: RedactableWithPolicy<P>,
        P: RedactionPolicy;

    /// Maps a sensitive scalar value to its default.
    ///
    /// Scalars are marked with bare `#[sensitive]` and can only use `#[sensitive(Default)]`.
    fn map_scalar<S>(&self, value: S) -> S
    where
        S: Default + ScalarRedaction;
}

/// The default mapper that applies redaction policies.
#[derive(Clone, Copy, Debug)]
struct PolicyMapper;

impl RedactableMapper for PolicyMapper {
    fn map_sensitive<V, P>(&self, value: V) -> V
    where
        V: RedactableWithPolicy<P>,
        P: RedactionPolicy,
    {
        value.redact_with_policy(&P::policy())
    }

    fn map_scalar<S>(&self, value: S) -> S
    where
        S: Default + ScalarRedaction,
    {
        // Special case: char defaults to '\0' which isn't useful, so use '*' instead
        // We use a helper trait to handle this cleanly
        ScalarRedaction::redact(value)
    }
}

// =============================================================================
// ScalarRedaction - Helper for scalar defaults
// =============================================================================

/// Helper trait to handle scalar redaction, with special cases.
#[doc(hidden)]
pub trait ScalarRedaction: Default {
    #[must_use]
    fn redact(self) -> Self {
        Self::default()
    }
}

impl ScalarRedaction for i8 {}
impl ScalarRedaction for i16 {}
impl ScalarRedaction for i32 {}
impl ScalarRedaction for i64 {}
impl ScalarRedaction for i128 {}
impl ScalarRedaction for isize {}
impl ScalarRedaction for u8 {}
impl ScalarRedaction for u16 {}
impl ScalarRedaction for u32 {}
impl ScalarRedaction for u64 {}
impl ScalarRedaction for u128 {}
impl ScalarRedaction for usize {}
impl ScalarRedaction for f32 {}
impl ScalarRedaction for f64 {}
impl ScalarRedaction for bool {}

impl ScalarRedaction for char {
    fn redact(self) -> Self {
        '*'
    }
}

// =============================================================================
// redact() - Entry point function
// =============================================================================

/// Redacts a value using policy-bound redaction.
///
/// The traversal is defined by [`RedactableContainer`] implementations, typically
/// generated by the derive macro.
///
/// This function is total: policy application does not propagate errors. Any
/// failure handling is performed by the selected policy implementation.
pub fn redact<W>(value: W) -> W
where
    W: RedactableContainer,
{
    let mapper = PolicyMapper;
    value.redact_with(&mapper)
}

/// Applies a redaction policy to a policy-applicable value.
///
/// This is a convenience wrapper used by redacted display implementations.
pub fn apply_policy<P, V>(value: V) -> V
where
    P: RedactionPolicy,
    V: PolicyApplicable,
{
    let mapper = PolicyMapper;
    value.apply_policy::<P, _>(&mapper)
}

// =============================================================================
// PolicyApplicable - Recursive policy application
// =============================================================================

/// A type that can have a redaction policy applied recursively to its inner values.
///
/// This trait enables `#[sensitive(Policy)]` to work on nested wrapper types
/// like `Option<Vec<String>>` by recursively delegating through each wrapper layer
/// until reaching a leaf type that implements [`RedactableLeaf`].
///
/// ## Implementors
///
/// - **Wrapper types** (`Option`, `Vec`, `Box`, maps, sets): Recursively apply to contents
/// - **Leaf types** (`String`, `Cow<str>`): Apply the redaction policy directly
///
/// ## Example
///
/// ```ignore
/// #[derive(Clone, Sensitive)]
/// struct User {
///     #[sensitive(Email)]
///     emails: Option<Vec<String>>,  // Works! Recursively applies Email to each String
/// }
/// ```
#[diagnostic::on_unimplemented(
    message = "`{Self}` cannot have a policy applied",
    label = "this type doesn't support redaction policies",
    note = "policies work on String, Cow<str>, and containers of these types",
    note = "for custom string-like types, implement `RedactableLeaf`"
)]
#[doc(hidden)]
pub trait PolicyApplicable {
    /// Applies a redaction policy through the type structure.
    ///
    /// For wrapper types, this recursively applies to inner values.
    /// For leaf types, this applies the policy directly.
    #[must_use]
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper;
}

// =============================================================================
// PolicyApplicable: Base case implementations (leaf types)
// =============================================================================

impl PolicyApplicable for String {
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        mapper.map_sensitive::<_, P>(self)
    }
}

impl PolicyApplicable for Cow<'_, str> {
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        mapper.map_sensitive::<_, P>(self)
    }
}

// =============================================================================
// PolicyApplicable: Recursive implementations (wrapper types)
// =============================================================================

impl<T: PolicyApplicable> PolicyApplicable for Option<T> {
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        self.map(|v| v.apply_policy::<P, M>(mapper))
    }
}

impl<T: PolicyApplicable> PolicyApplicable for Vec<T> {
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        self.into_iter()
            .map(|v| v.apply_policy::<P, M>(mapper))
            .collect()
    }
}

impl<T: PolicyApplicable> PolicyApplicable for Box<T> {
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        Box::new((*self).apply_policy::<P, M>(mapper))
    }
}

impl<T, E> PolicyApplicable for Result<T, E>
where
    T: PolicyApplicable,
    E: PolicyApplicable,
{
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        match self {
            Ok(v) => Ok(v.apply_policy::<P, M>(mapper)),
            Err(e) => Err(e.apply_policy::<P, M>(mapper)),
        }
    }
}

// Maps: apply policy to values only (keys unchanged)
impl<K, V, S> PolicyApplicable for HashMap<K, V, S>
where
    K: Hash + Eq,
    V: PolicyApplicable,
    S: BuildHasher + Clone,
{
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        let hasher = self.hasher().clone();
        let mut result = HashMap::with_hasher(hasher);
        result.extend(
            self.into_iter()
                .map(|(k, v)| (k, v.apply_policy::<P, M>(mapper))),
        );
        result
    }
}

impl<K, V> PolicyApplicable for BTreeMap<K, V>
where
    K: Ord,
    V: PolicyApplicable,
{
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        self.into_iter()
            .map(|(k, v)| (k, v.apply_policy::<P, M>(mapper)))
            .collect()
    }
}

// Sets: apply policy to elements
impl<T, S> PolicyApplicable for HashSet<T, S>
where
    T: PolicyApplicable + Hash + Eq,
    S: BuildHasher + Clone,
{
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        let hasher = self.hasher().clone();
        let mut result = HashSet::with_hasher(hasher);
        result.extend(self.into_iter().map(|v| v.apply_policy::<P, M>(mapper)));
        result
    }
}

impl<T> PolicyApplicable for BTreeSet<T>
where
    T: PolicyApplicable + Ord,
{
    fn apply_policy<P, M>(self, mapper: &M) -> Self
    where
        P: RedactionPolicy,
        M: RedactableMapper,
    {
        self.into_iter()
            .map(|v| v.apply_policy::<P, M>(mapper))
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use super::redact;
    use crate::{Default, Sensitive};

    #[test]
    fn redact_applies_policy() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct DefaultValue {
            #[sensitive(Default)]
            value: String,
        }

        let value = DefaultValue {
            value: "top_secret".to_string(),
        };
        let redacted = redact(value);
        assert_eq!(redacted.value, "[REDACTED]");
    }

    #[test]
    fn apply_policy_to_string() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct Simple {
            #[sensitive(Default)]
            value: String,
        }

        let s = Simple {
            value: "secret".into(),
        };
        let redacted = redact(s);
        assert_eq!(redacted.value, "[REDACTED]");
    }

    #[test]
    fn apply_policy_to_option_string() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct WithOption {
            #[sensitive(Default)]
            value: Option<String>,
        }

        let s = WithOption {
            value: Some("secret".into()),
        };
        let redacted = redact(s);
        assert_eq!(redacted.value, Some("[REDACTED]".into()));
    }

    #[test]
    fn apply_policy_to_vec_string() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct WithVec {
            #[sensitive(Default)]
            values: Vec<String>,
        }

        let s = WithVec {
            values: vec!["secret1".into(), "secret2".into()],
        };
        let redacted = redact(s);
        assert_eq!(redacted.values, vec!["[REDACTED]", "[REDACTED]"]);
    }

    #[test]
    fn apply_policy_to_nested_option_vec() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct Nested {
            #[sensitive(Default)]
            values: Option<Vec<String>>,
        }

        let s = Nested {
            values: Some(vec!["secret1".into(), "secret2".into()]),
        };
        let redacted = redact(s);
        assert_eq!(
            redacted.values,
            Some(vec!["[REDACTED]".into(), "[REDACTED]".into()])
        );
    }

    #[test]
    fn apply_policy_to_nested_vec_option() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct Nested {
            #[sensitive(Default)]
            values: Vec<Option<String>>,
        }

        let s = Nested {
            values: vec![Some("secret1".into()), None, Some("secret2".into())],
        };
        let redacted = redact(s);
        assert_eq!(
            redacted.values,
            vec![Some("[REDACTED]".into()), None, Some("[REDACTED]".into())]
        );
    }

    #[test]
    fn apply_policy_to_deeply_nested() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct DeepNest {
            #[sensitive(Default)]
            values: Option<Vec<Option<String>>>,
        }

        let s = DeepNest {
            values: Some(vec![Some("secret".into()), None]),
        };
        let redacted = redact(s);
        assert_eq!(redacted.values, Some(vec![Some("[REDACTED]".into()), None]));
    }

    #[test]
    fn apply_policy_to_hashmap_values() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct WithMap {
            #[sensitive(Default)]
            data: HashMap<String, String>,
        }

        let mut data = HashMap::new();
        data.insert("key1".into(), "secret1".into());
        data.insert("key2".into(), "secret2".into());

        let s = WithMap { data };
        let redacted = redact(s);

        // Keys preserved, values redacted
        assert!(redacted.data.contains_key("key1"));
        assert!(redacted.data.contains_key("key2"));
        assert_eq!(redacted.data.get("key1"), Some(&"[REDACTED]".to_string()));
        assert_eq!(redacted.data.get("key2"), Some(&"[REDACTED]".to_string()));
    }

    #[test]
    fn apply_policy_to_nested_map_vec() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct ComplexNest {
            #[sensitive(Default)]
            data: HashMap<String, Vec<String>>,
        }

        let mut data = HashMap::new();
        data.insert("secrets".into(), vec!["secret1".into(), "secret2".into()]);

        let s = ComplexNest { data };
        let redacted = redact(s);

        assert_eq!(
            redacted.data.get("secrets"),
            Some(&vec!["[REDACTED]".to_string(), "[REDACTED]".to_string()])
        );
    }
}
